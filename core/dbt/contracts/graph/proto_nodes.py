# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: nodes.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import (
    Dict,
    List,
    Optional,
)

import betterproto


@dataclass(eq=False, repr=False)
class ListOfStrings(betterproto.Message):
    value: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class Docs(betterproto.Message):
    show: bool = betterproto.bool_field(1)
    node_color: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class MacroDependsOn(betterproto.Message):
    macros: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class DependsOn(betterproto.Message):
    macros: List[str] = betterproto.string_field(1)
    nodes: List[str] = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class MacroArgument(betterproto.Message):
    name: str = betterproto.string_field(1)
    type: Optional[str] = betterproto.string_field(2, optional=True, group="_type")
    description: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class Quoting(betterproto.Message):
    database: Optional[str] = betterproto.string_field(1, optional=True, group="_database")
    schema: Optional[str] = betterproto.string_field(2, optional=True, group="_schema")
    identifier: Optional[str] = betterproto.string_field(3, optional=True, group="_identifier")
    column: Optional[str] = betterproto.string_field(4, optional=True, group="_column")


@dataclass(eq=False, repr=False)
class Time(betterproto.Message):
    count: Optional[int] = betterproto.int32_field(1, optional=True, group="_count")
    period: Optional[str] = betterproto.string_field(2, optional=True, group="_period")


@dataclass(eq=False, repr=False)
class FreshnessThreshold(betterproto.Message):
    warn_after: Optional["Time"] = betterproto.message_field(1, optional=True, group="_warn_after")
    error_after: Optional["Time"] = betterproto.message_field(
        2, optional=True, group="_error_after"
    )
    filter: Optional[str] = betterproto.string_field(3, optional=True, group="_filter")


@dataclass(eq=False, repr=False)
class ExposureOwner(betterproto.Message):
    email: str = betterproto.string_field(1)
    name: Optional[str] = betterproto.string_field(2, optional=True, group="_name")


@dataclass(eq=False, repr=False)
class MetricFilter(betterproto.Message):
    field: str = betterproto.string_field(1)
    operator: str = betterproto.string_field(2)
    value: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class MetricTime(betterproto.Message):
    count: Optional[int] = betterproto.int32_field(1, optional=True, group="_count")
    period: Optional[str] = betterproto.string_field(2, optional=True, group="_period")


@dataclass(eq=False, repr=False)
class NodeConfig(betterproto.Message):
    enabled: bool = betterproto.bool_field(1)
    alias: Optional[str] = betterproto.string_field(2, optional=True, group="_alias")
    schema: Optional[str] = betterproto.string_field(3, optional=True, group="_schema")
    database: Optional[str] = betterproto.string_field(4, optional=True, group="_database")
    tags: List[str] = betterproto.string_field(5)
    meta: Dict[str, str] = betterproto.map_field(
        6, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    materialized: str = betterproto.string_field(7)
    incremental_strategy: Optional[str] = betterproto.string_field(
        8, optional=True, group="_incremental_strategy"
    )
    persist_docs: Dict[str, str] = betterproto.map_field(
        9, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    quoting: Dict[str, str] = betterproto.map_field(
        12, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    """post_hook = 10; pre_hook = 11;"""

    column_types: Dict[str, str] = betterproto.map_field(
        13, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    full_refresh: Optional[bool] = betterproto.bool_field(14, optional=True, group="_full_refresh")
    unique_key: Optional[str] = betterproto.string_field(15, optional=True, group="_unique_key")
    on_schema_change: str = betterproto.string_field(16)
    grants: Dict[str, str] = betterproto.map_field(
        17, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    packages: List[str] = betterproto.string_field(18)
    docs: "Docs" = betterproto.message_field(19)


@dataclass(eq=False, repr=False)
class SeedConfig(betterproto.Message):
    enabled: bool = betterproto.bool_field(1)
    alias: Optional[str] = betterproto.string_field(2, optional=True, group="_alias")
    schema: Optional[str] = betterproto.string_field(3, optional=True, group="_schema")
    database: Optional[str] = betterproto.string_field(4, optional=True, group="_database")
    tags: List[str] = betterproto.string_field(5)
    meta: Dict[str, str] = betterproto.map_field(
        6, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    materialized: str = betterproto.string_field(7)
    incremental_strategy: Optional[str] = betterproto.string_field(
        8, optional=True, group="_incremental_strategy"
    )
    persist_docs: Dict[str, str] = betterproto.map_field(
        9, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    quoting: Dict[str, str] = betterproto.map_field(
        12, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    """post_hook = 10; pre_hook = 11;"""

    column_types: Dict[str, str] = betterproto.map_field(
        13, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    full_refresh: Optional[bool] = betterproto.bool_field(14, optional=True, group="_full_refresh")
    unique_key: Optional[str] = betterproto.string_field(15, optional=True, group="_unique_key")
    on_schema_change: str = betterproto.string_field(16)
    grants: Dict[str, str] = betterproto.map_field(
        17, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    packages: List[str] = betterproto.string_field(18)
    docs: "Docs" = betterproto.message_field(19)
    quote_columns: Optional[bool] = betterproto.bool_field(
        20, optional=True, group="_quote_columns"
    )


@dataclass(eq=False, repr=False)
class TestConfig(betterproto.Message):
    enabled: bool = betterproto.bool_field(1)
    alias: Optional[str] = betterproto.string_field(2, optional=True, group="_alias")
    schema: Optional[str] = betterproto.string_field(3, optional=True, group="_schema")
    database: Optional[str] = betterproto.string_field(4, optional=True, group="_database")
    tags: List[str] = betterproto.string_field(5)
    meta: Dict[str, str] = betterproto.map_field(
        6, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    materialized: str = betterproto.string_field(8)
    severity: str = betterproto.string_field(9)
    store_failures: Optional[bool] = betterproto.bool_field(
        10, optional=True, group="_store_failures"
    )
    where: Optional[str] = betterproto.string_field(11, optional=True, group="_where")
    limit: Optional[int] = betterproto.int32_field(12, optional=True, group="_limit")
    fail_calc: str = betterproto.string_field(13)
    warn_if: str = betterproto.string_field(14)
    error_if: str = betterproto.string_field(15)


@dataclass(eq=False, repr=False)
class SnapshotConfig(betterproto.Message):
    """NodeConfig plus strategy, target_schema, target_database, check_cols"""

    enabled: bool = betterproto.bool_field(1)
    alias: Optional[str] = betterproto.string_field(2, optional=True, group="_alias")
    schema: Optional[str] = betterproto.string_field(3, optional=True, group="_schema")
    database: Optional[str] = betterproto.string_field(4, optional=True, group="_database")
    tags: List[str] = betterproto.string_field(5)
    meta: Dict[str, str] = betterproto.map_field(
        6, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    materialized: str = betterproto.string_field(7)
    incremental_strategy: Optional[str] = betterproto.string_field(
        8, optional=True, group="_incremental_strategy"
    )
    persist_docs: Dict[str, str] = betterproto.map_field(
        9, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    quoting: Dict[str, str] = betterproto.map_field(
        12, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    """post_hook = 10; pre_hook = 11;"""

    column_types: Dict[str, str] = betterproto.map_field(
        13, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    full_refresh: Optional[bool] = betterproto.bool_field(14, optional=True, group="_full_refresh")
    unique_key: Optional[str] = betterproto.string_field(15, optional=True, group="_unique_key")
    on_schema_change: str = betterproto.string_field(16)
    grants: Dict[str, str] = betterproto.map_field(
        17, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    packages: List[str] = betterproto.string_field(18)
    docs: "Docs" = betterproto.message_field(19)
    strategy: Optional[str] = betterproto.string_field(20, optional=True, group="_strategy")
    target_schema: Optional[str] = betterproto.string_field(
        21, optional=True, group="_target_schema"
    )
    target_database: Optional[str] = betterproto.string_field(
        22, optional=True, group="_target_database"
    )
    check_cols: List[str] = betterproto.string_field(23)


@dataclass(eq=False, repr=False)
class SourceConfig(betterproto.Message):
    enabled: bool = betterproto.bool_field(1)


@dataclass(eq=False, repr=False)
class ExposureConfig(betterproto.Message):
    enabled: bool = betterproto.bool_field(1)


@dataclass(eq=False, repr=False)
class MetricConfig(betterproto.Message):
    enabled: bool = betterproto.bool_field(1)


@dataclass(eq=False, repr=False)
class ColumnInfo(betterproto.Message):
    name: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    meta: Dict[str, str] = betterproto.map_field(
        3, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    data_type: str = betterproto.string_field(4)
    quote: Optional[bool] = betterproto.bool_field(5, optional=True, group="_quote")
    tags: List[str] = betterproto.string_field(6)
    extra: Dict[str, str] = betterproto.map_field(
        7, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass(eq=False, repr=False)
class ModelNode(betterproto.Message):
    """
    There are three nodes that are exactly the same as this one (AnalysisNode,
    RPCNode, and SqlNOde), and one with only one additional attribute
    (HookNode). Making separate messages for now, but we can revisit later. If
    we clean up the config classes, some of those nodes might end up with
    different config classes, which would require separate node messages.
    """

    name: str = betterproto.string_field(1)
    resource_type: str = betterproto.string_field(2)
    package_name: str = betterproto.string_field(3)
    path: str = betterproto.string_field(4)
    original_file_path: str = betterproto.string_field(5)
    unique_id: str = betterproto.string_field(6)
    fqn: List[str] = betterproto.string_field(7)
    database: Optional[str] = betterproto.string_field(8, optional=True, group="_database")
    schema: str = betterproto.string_field(9)
    alias: str = betterproto.string_field(10)
    config: "NodeConfig" = betterproto.message_field(11)
    tags: List[str] = betterproto.string_field(12)
    description: str = betterproto.string_field(13)
    columns: Dict[str, "ColumnInfo"] = betterproto.map_field(
        14, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    meta: Dict[str, str] = betterproto.map_field(
        15, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    docs: "Docs" = betterproto.message_field(16)
    patch_path: str = betterproto.string_field(17)
    deferred: bool = betterproto.bool_field(18)
    unrendered_config: Dict[str, str] = betterproto.map_field(
        19, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    relation_name: str = betterproto.string_field(20)
    raw_code: str = betterproto.string_field(21)
    language: str = betterproto.string_field(22)
    refs: List["ListOfStrings"] = betterproto.message_field(23)
    sources: List["ListOfStrings"] = betterproto.message_field(24)
    metrics: List["ListOfStrings"] = betterproto.message_field(25)
    depends_on: "DependsOn" = betterproto.message_field(26)
    compiled: bool = betterproto.bool_field(27)
    compiled_code: str = betterproto.string_field(28)


@dataclass(eq=False, repr=False)
class AnalysisNode(betterproto.Message):
    """This should be exactly the same as ModelNode"""

    name: str = betterproto.string_field(1)
    resource_type: str = betterproto.string_field(2)
    package_name: str = betterproto.string_field(3)
    path: str = betterproto.string_field(4)
    original_file_path: str = betterproto.string_field(5)
    unique_id: str = betterproto.string_field(6)
    fqn: List[str] = betterproto.string_field(7)
    database: Optional[str] = betterproto.string_field(8, optional=True, group="_database")
    schema: str = betterproto.string_field(9)
    alias: str = betterproto.string_field(10)
    config: "NodeConfig" = betterproto.message_field(11)
    tags: List[str] = betterproto.string_field(12)
    description: str = betterproto.string_field(13)
    columns: Dict[str, "ColumnInfo"] = betterproto.map_field(
        14, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    meta: Dict[str, str] = betterproto.map_field(
        15, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    docs: "Docs" = betterproto.message_field(16)
    patch_path: str = betterproto.string_field(17)
    deferred: bool = betterproto.bool_field(18)
    unrendered_config: Dict[str, str] = betterproto.map_field(
        19, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    relation_name: str = betterproto.string_field(20)
    raw_code: str = betterproto.string_field(21)
    language: str = betterproto.string_field(22)
    refs: List["ListOfStrings"] = betterproto.message_field(23)
    sources: List["ListOfStrings"] = betterproto.message_field(24)
    metrics: List["ListOfStrings"] = betterproto.message_field(25)
    depends_on: "DependsOn" = betterproto.message_field(26)
    compiled: bool = betterproto.bool_field(27)
    compiled_code: str = betterproto.string_field(28)


@dataclass(eq=False, repr=False)
class RPCNode(betterproto.Message):
    """This should be exactly the same as ModelNode"""

    name: str = betterproto.string_field(1)
    resource_type: str = betterproto.string_field(2)
    package_name: str = betterproto.string_field(3)
    path: str = betterproto.string_field(4)
    original_file_path: str = betterproto.string_field(5)
    unique_id: str = betterproto.string_field(6)
    fqn: List[str] = betterproto.string_field(7)
    database: Optional[str] = betterproto.string_field(8, optional=True, group="_database")
    schema: str = betterproto.string_field(9)
    alias: str = betterproto.string_field(10)
    config: "NodeConfig" = betterproto.message_field(11)
    tags: List[str] = betterproto.string_field(12)
    description: str = betterproto.string_field(13)
    columns: Dict[str, "ColumnInfo"] = betterproto.map_field(
        14, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    meta: Dict[str, str] = betterproto.map_field(
        15, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    docs: "Docs" = betterproto.message_field(16)
    patch_path: str = betterproto.string_field(17)
    deferred: bool = betterproto.bool_field(18)
    unrendered_config: Dict[str, str] = betterproto.map_field(
        19, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    relation_name: str = betterproto.string_field(20)
    raw_code: str = betterproto.string_field(21)
    language: str = betterproto.string_field(22)
    refs: List["ListOfStrings"] = betterproto.message_field(23)
    sources: List["ListOfStrings"] = betterproto.message_field(24)
    metrics: List["ListOfStrings"] = betterproto.message_field(25)
    depends_on: "DependsOn" = betterproto.message_field(26)
    compiled: bool = betterproto.bool_field(27)
    compiled_code: str = betterproto.string_field(28)


@dataclass(eq=False, repr=False)
class SqlNode(betterproto.Message):
    """This should be exactly the same as ModelNode"""

    name: str = betterproto.string_field(1)
    resource_type: str = betterproto.string_field(2)
    package_name: str = betterproto.string_field(3)
    path: str = betterproto.string_field(4)
    original_file_path: str = betterproto.string_field(5)
    unique_id: str = betterproto.string_field(6)
    fqn: List[str] = betterproto.string_field(7)
    database: Optional[str] = betterproto.string_field(8, optional=True, group="_database")
    schema: str = betterproto.string_field(9)
    alias: str = betterproto.string_field(10)
    config: "NodeConfig" = betterproto.message_field(11)
    tags: List[str] = betterproto.string_field(12)
    description: str = betterproto.string_field(13)
    columns: Dict[str, "ColumnInfo"] = betterproto.map_field(
        14, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    meta: Dict[str, str] = betterproto.map_field(
        15, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    docs: "Docs" = betterproto.message_field(16)
    patch_path: str = betterproto.string_field(17)
    deferred: bool = betterproto.bool_field(18)
    unrendered_config: Dict[str, str] = betterproto.map_field(
        19, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    relation_name: str = betterproto.string_field(20)
    raw_code: str = betterproto.string_field(21)
    language: str = betterproto.string_field(22)
    refs: List["ListOfStrings"] = betterproto.message_field(23)
    sources: List["ListOfStrings"] = betterproto.message_field(24)
    metrics: List["ListOfStrings"] = betterproto.message_field(25)
    depends_on: "DependsOn" = betterproto.message_field(26)
    compiled: bool = betterproto.bool_field(27)
    compiled_code: str = betterproto.string_field(28)


@dataclass(eq=False, repr=False)
class HookNode(betterproto.Message):
    """
    This should be the same as ModelNode plus additional "index" attribute
    """

    name: str = betterproto.string_field(1)
    resource_type: str = betterproto.string_field(2)
    package_name: str = betterproto.string_field(3)
    path: str = betterproto.string_field(4)
    original_file_path: str = betterproto.string_field(5)
    unique_id: str = betterproto.string_field(6)
    fqn: List[str] = betterproto.string_field(7)
    database: Optional[str] = betterproto.string_field(8, optional=True, group="_database")
    schema: str = betterproto.string_field(9)
    alias: str = betterproto.string_field(10)
    config: "NodeConfig" = betterproto.message_field(11)
    tags: List[str] = betterproto.string_field(12)
    description: str = betterproto.string_field(13)
    columns: Dict[str, "ColumnInfo"] = betterproto.map_field(
        14, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    meta: Dict[str, str] = betterproto.map_field(
        15, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    docs: "Docs" = betterproto.message_field(16)
    patch_path: str = betterproto.string_field(17)
    deferred: bool = betterproto.bool_field(18)
    unrendered_config: Dict[str, str] = betterproto.map_field(
        19, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    relation_name: str = betterproto.string_field(20)
    raw_code: str = betterproto.string_field(21)
    language: str = betterproto.string_field(22)
    refs: List["ListOfStrings"] = betterproto.message_field(23)
    sources: List["ListOfStrings"] = betterproto.message_field(24)
    metrics: List["ListOfStrings"] = betterproto.message_field(25)
    depends_on: "DependsOn" = betterproto.message_field(26)
    compiled: bool = betterproto.bool_field(27)
    compiled_code: str = betterproto.string_field(28)
    index: Optional[int] = betterproto.int32_field(29, optional=True, group="_index")


@dataclass(eq=False, repr=False)
class SeedNode(betterproto.Message):
    name: str = betterproto.string_field(1)
    resource_type: str = betterproto.string_field(2)
    package_name: str = betterproto.string_field(3)
    path: str = betterproto.string_field(4)
    original_file_path: str = betterproto.string_field(5)
    unique_id: str = betterproto.string_field(6)
    fqn: List[str] = betterproto.string_field(7)
    database: Optional[str] = betterproto.string_field(8, optional=True, group="_database")
    schema: str = betterproto.string_field(9)
    alias: str = betterproto.string_field(10)
    config: "SeedConfig" = betterproto.message_field(11)
    tags: List[str] = betterproto.string_field(12)
    description: str = betterproto.string_field(13)
    columns: Dict[str, "ColumnInfo"] = betterproto.map_field(
        14, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    meta: Dict[str, str] = betterproto.map_field(
        15, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    docs: "Docs" = betterproto.message_field(16)
    patch_path: str = betterproto.string_field(17)
    deferred: bool = betterproto.bool_field(18)
    unrendered_config: Dict[str, str] = betterproto.map_field(
        19, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    relation_name: str = betterproto.string_field(20)
    raw_code: str = betterproto.string_field(21)
    root_path: str = betterproto.string_field(22)


@dataclass(eq=False, repr=False)
class SingularTestNode(betterproto.Message):
    """Same as ModelNode except config is TestConfig"""

    name: str = betterproto.string_field(1)
    resource_type: str = betterproto.string_field(2)
    package_name: str = betterproto.string_field(3)
    path: str = betterproto.string_field(4)
    original_file_path: str = betterproto.string_field(5)
    unique_id: str = betterproto.string_field(6)
    fqn: List[str] = betterproto.string_field(7)
    database: Optional[str] = betterproto.string_field(8, optional=True, group="_database")
    schema: str = betterproto.string_field(9)
    alias: str = betterproto.string_field(10)
    config: "TestConfig" = betterproto.message_field(11)
    tags: List[str] = betterproto.string_field(12)
    description: str = betterproto.string_field(13)
    columns: Dict[str, "ColumnInfo"] = betterproto.map_field(
        14, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    meta: Dict[str, str] = betterproto.map_field(
        15, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    docs: "Docs" = betterproto.message_field(16)
    patch_path: str = betterproto.string_field(17)
    deferred: bool = betterproto.bool_field(18)
    unrendered_config: Dict[str, str] = betterproto.map_field(
        19, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    relation_name: str = betterproto.string_field(20)
    raw_code: str = betterproto.string_field(21)
    language: str = betterproto.string_field(22)
    refs: List["ListOfStrings"] = betterproto.message_field(23)
    sources: List["ListOfStrings"] = betterproto.message_field(24)
    metrics: List["ListOfStrings"] = betterproto.message_field(25)
    depends_on: "DependsOn" = betterproto.message_field(26)
    compiled: bool = betterproto.bool_field(27)
    compiled_code: str = betterproto.string_field(28)


@dataclass(eq=False, repr=False)
class TestMetadata(betterproto.Message):
    name: str = betterproto.string_field(1)
    kwargs: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    namespace: Optional[str] = betterproto.string_field(3, optional=True, group="_namespace")


@dataclass(eq=False, repr=False)
class GenericTestNode(betterproto.Message):
    """
    Same as ModelNode except config is TestConfig, and has test_metadata and
    column_name attributes.
    """

    name: str = betterproto.string_field(1)
    resource_type: str = betterproto.string_field(2)
    package_name: str = betterproto.string_field(3)
    path: str = betterproto.string_field(4)
    original_file_path: str = betterproto.string_field(5)
    unique_id: str = betterproto.string_field(6)
    fqn: List[str] = betterproto.string_field(7)
    database: Optional[str] = betterproto.string_field(8, optional=True, group="_database")
    schema: str = betterproto.string_field(9)
    alias: str = betterproto.string_field(10)
    config: "TestConfig" = betterproto.message_field(11)
    tags: List[str] = betterproto.string_field(12)
    description: str = betterproto.string_field(13)
    columns: Dict[str, "ColumnInfo"] = betterproto.map_field(
        14, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    meta: Dict[str, str] = betterproto.map_field(
        15, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    docs: "Docs" = betterproto.message_field(16)
    patch_path: str = betterproto.string_field(17)
    deferred: bool = betterproto.bool_field(18)
    unrendered_config: Dict[str, str] = betterproto.map_field(
        19, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    relation_name: str = betterproto.string_field(20)
    raw_code: str = betterproto.string_field(21)
    language: str = betterproto.string_field(22)
    refs: List["ListOfStrings"] = betterproto.message_field(23)
    sources: List["ListOfStrings"] = betterproto.message_field(24)
    metrics: List["ListOfStrings"] = betterproto.message_field(25)
    depends_on: "DependsOn" = betterproto.message_field(26)
    compiled: bool = betterproto.bool_field(27)
    compiled_code: str = betterproto.string_field(28)
    test_metadata: "TestMetadata" = betterproto.message_field(29)
    column_name: Optional[str] = betterproto.string_field(30, optional=True, group="_column_name")


@dataclass(eq=False, repr=False)
class SnapshotNode(betterproto.Message):
    """SnapshotNode - Sames as ModelNode except with SnapshotConfig"""

    name: str = betterproto.string_field(1)
    resource_type: str = betterproto.string_field(2)
    package_name: str = betterproto.string_field(3)
    path: str = betterproto.string_field(4)
    original_file_path: str = betterproto.string_field(5)
    unique_id: str = betterproto.string_field(6)
    fqn: List[str] = betterproto.string_field(7)
    database: Optional[str] = betterproto.string_field(8, optional=True, group="_database")
    schema: str = betterproto.string_field(9)
    alias: str = betterproto.string_field(10)
    config: "SnapshotConfig" = betterproto.message_field(11)
    tags: List[str] = betterproto.string_field(12)
    description: str = betterproto.string_field(13)
    columns: Dict[str, "ColumnInfo"] = betterproto.map_field(
        14, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    meta: Dict[str, str] = betterproto.map_field(
        15, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    docs: "Docs" = betterproto.message_field(16)
    patch_path: str = betterproto.string_field(17)
    deferred: bool = betterproto.bool_field(18)
    unrendered_config: Dict[str, str] = betterproto.map_field(
        19, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    relation_name: str = betterproto.string_field(20)
    raw_code: str = betterproto.string_field(21)
    language: str = betterproto.string_field(22)
    refs: List["ListOfStrings"] = betterproto.message_field(23)
    sources: List["ListOfStrings"] = betterproto.message_field(24)
    metrics: List["ListOfStrings"] = betterproto.message_field(25)
    depends_on: "DependsOn" = betterproto.message_field(26)
    compiled: bool = betterproto.bool_field(27)
    compiled_code: str = betterproto.string_field(28)


@dataclass(eq=False, repr=False)
class Macro(betterproto.Message):
    """Macro - BaseNode plus additional attributes"""

    name: str = betterproto.string_field(1)
    resource_type: str = betterproto.string_field(2)
    package_name: str = betterproto.string_field(3)
    path: str = betterproto.string_field(4)
    original_file_path: str = betterproto.string_field(5)
    unique_id: str = betterproto.string_field(6)
    macro_sql: str = betterproto.string_field(7)
    depends_on: "MacroDependsOn" = betterproto.message_field(8)
    description: str = betterproto.string_field(9)
    meta: Dict[str, str] = betterproto.map_field(
        10, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    docs: "Docs" = betterproto.message_field(11)
    patch_path: Optional[str] = betterproto.string_field(12, optional=True, group="_patch_path")
    arguments: List["MacroArgument"] = betterproto.message_field(13)
    supported_languages: List[str] = betterproto.string_field(14)


@dataclass(eq=False, repr=False)
class Documentation(betterproto.Message):
    """Documentation - BaseNode plus block_contents"""

    name: str = betterproto.string_field(1)
    resource_type: str = betterproto.string_field(2)
    package_name: str = betterproto.string_field(3)
    path: str = betterproto.string_field(4)
    original_file_path: str = betterproto.string_field(5)
    unique_id: str = betterproto.string_field(6)
    block_contents: str = betterproto.string_field(7)


@dataclass(eq=False, repr=False)
class SourceDefinition(betterproto.Message):
    name: str = betterproto.string_field(1)
    resource_type: str = betterproto.string_field(2)
    package_name: str = betterproto.string_field(3)
    path: str = betterproto.string_field(4)
    original_file_path: str = betterproto.string_field(5)
    unique_id: str = betterproto.string_field(6)
    fqn: List[str] = betterproto.string_field(7)
    database: Optional[str] = betterproto.string_field(8, optional=True, group="_database")
    schema: str = betterproto.string_field(9)
    source_name: str = betterproto.string_field(10)
    source_description: str = betterproto.string_field(11)
    loader: str = betterproto.string_field(12)
    identifier: str = betterproto.string_field(13)
    quoting: "Quoting" = betterproto.message_field(14)
    loaded_at_field: Optional[str] = betterproto.string_field(
        15, optional=True, group="_loaded_at_field"
    )
    freshness: Optional["FreshnessThreshold"] = betterproto.message_field(
        16, optional=True, group="_freshness"
    )
    description: str = betterproto.string_field(18)
    """optional ExternalTable external = 17;"""

    columns: Dict[str, "ColumnInfo"] = betterproto.map_field(
        19, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    meta: Dict[str, str] = betterproto.map_field(
        20, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    source_meta: Dict[str, str] = betterproto.map_field(
        21, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    tags: List[str] = betterproto.string_field(22)
    config: "SourceConfig" = betterproto.message_field(23)
    patch_path: Optional[str] = betterproto.string_field(24, optional=True, group="_patch_path")
    unrendered_config: Dict[str, str] = betterproto.map_field(
        25, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    relation_name: Optional[str] = betterproto.string_field(
        26, optional=True, group="_relation_name"
    )


@dataclass(eq=False, repr=False)
class Exposure(betterproto.Message):
    name: str = betterproto.string_field(1)
    resource_type: str = betterproto.string_field(2)
    package_name: str = betterproto.string_field(3)
    path: str = betterproto.string_field(4)
    original_file_path: str = betterproto.string_field(5)
    unique_id: str = betterproto.string_field(6)
    fqn: List[str] = betterproto.string_field(7)
    type: str = betterproto.string_field(8)
    owner: "ExposureOwner" = betterproto.message_field(9)
    description: str = betterproto.string_field(10)
    label: Optional[str] = betterproto.string_field(11, optional=True, group="_label")
    maturity: Optional[str] = betterproto.string_field(12, optional=True, group="_maturity")
    meta: Dict[str, str] = betterproto.map_field(
        13, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    tags: List[str] = betterproto.string_field(14)
    config: "ExposureConfig" = betterproto.message_field(15)
    unrendered_config: Dict[str, str] = betterproto.map_field(
        16, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    url: Optional[str] = betterproto.string_field(17, optional=True, group="_url")
    depends_on: "DependsOn" = betterproto.message_field(18)
    refs: List["ListOfStrings"] = betterproto.message_field(24)
    sources: List["ListOfStrings"] = betterproto.message_field(25)
    metrics: List["ListOfStrings"] = betterproto.message_field(26)


@dataclass(eq=False, repr=False)
class Metric(betterproto.Message):
    name: str = betterproto.string_field(1)
    resource_type: str = betterproto.string_field(2)
    package_name: str = betterproto.string_field(3)
    path: str = betterproto.string_field(4)
    original_file_path: str = betterproto.string_field(5)
    unique_id: str = betterproto.string_field(6)
    fqn: List[str] = betterproto.string_field(7)
    description: str = betterproto.string_field(8)
    label: str = betterproto.string_field(9)
    calculation_method: str = betterproto.string_field(10)
    expression: str = betterproto.string_field(11)
    filters: List["MetricFilter"] = betterproto.message_field(12)
    time_grains: List[str] = betterproto.string_field(13)
    dimensions: List[str] = betterproto.string_field(14)
    timestamp: Optional[str] = betterproto.string_field(15, optional=True, group="_timestamp")
    window: Optional["MetricTime"] = betterproto.message_field(16, optional=True, group="_window")
    model: Optional[str] = betterproto.string_field(17, optional=True, group="_model")
    model_unique_id: Optional[str] = betterproto.string_field(
        18, optional=True, group="_model_unique_id"
    )
    meta: Dict[str, str] = betterproto.map_field(
        19, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    tags: List[str] = betterproto.string_field(20)
    config: "MetricConfig" = betterproto.message_field(21)
    unrendered_config: Dict[str, str] = betterproto.map_field(
        22, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    refs: List["ListOfStrings"] = betterproto.message_field(24)
    sources: List["ListOfStrings"] = betterproto.message_field(25)
    metrics: List["ListOfStrings"] = betterproto.message_field(26)
    depends_on: "DependsOn" = betterproto.message_field(27)
